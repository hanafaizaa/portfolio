---
title: "STA1373-Optimisasi Statistika: Pencarian Akar Persamaan/ Penyelesaian SPL"
author: "Sachnaz Desta Oktarina"
date: "2023-01-27"
output:
  pdf_document:
    toc: yes
  html_document:
    toc: yes
---

```{r include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

**Disclaimer**\
Please do not cite this document. Data and syntax can be reused freely while keep attributing and refering to the original source (where applicable) in the reference. This document is used for educational purpose only.

## Vector and Matrix

```{r}
u <- seq(1,5)
v <- seq(6,10)
u
v
```

##penjumlahan vektor
```{r}
u + v
```
##pengurangan vektor
```{r}
u - v
```

Bagaimana jika panjang kedua vektor berbeda?

```{r}
x <- seq(1,2)
x
u + x
```
Berdasarkan contoh tersebut, R akan mengeluarkan peringatan yang menunjukkan operasi dilakukan pada vektor dengan panjang berbeda. R akan tetap melakukan perhitungan dengan menjumlahkan kembali vektor u yang belum dijumlahkan dengan vektor x sampai seluruh elemen vektor u dilakukan operasi penjumlahan
Menghitung Inner Product dan Panjang Vektor

##Inner product
```{r}
u%*%v
```

##Panjang vektor
```{r}
sqrt(sum(u*u))
```

## Operasi Matrix
```{r}
A <- matrix(1:9,3)
B <- matrix(10:18,3)
C <- matrix(1:6,3)
A
B
C
```

##Penjumlahan A + B
```{r}
A+B
#A+C
```

##Perkalian
```{r}
A%*%B
```

## Operasi Baris Elementer
##Row Scaling
```{r}
scale_row <- function(m, row, k){
  m[row, ] <- m[row, ]*k
  return(m)
}

(A <- matrix(1:15, nrow=5))
```
lakukan scaling pada row 2 dengan nilai 10
```{r}
scale_row(m=A, row=2, 10)
```
##Row Swapping
```{r}
swap_row <- function(m, row1, row2){
  row_tmp <- m[row1, ]
  m[row1, ] <- m[row2, ]
  m[row2, ] <- row_tmp
  return(m)
}
```
Lakukan swapping baris 2 dengan baris 5 
```{r}
swap_row(m=A, row1 = 2, row2 = 5)
```

##Row replacement
```{r}
replace_row <- function(m, row1, row2, k){
  m[row2, ] <- m[row2, ] + m[row1, ]*k
  return(m)
}
```
Lakukan replacement 

```{r}
replace_row(m=A, row1=1, row2=3, k=-3)
```

## Eliminasi Gauss
##Row Echelon Form
```{r}
ref_matrix <- function(a){
  m <- nrow(a)
  n <- ncol(a)
  piv <- 1
  
  # cek elemen diagonal apakah bernilai nol
  for(row_curr in 1:m){
    if(piv <= n){
      i <- row_curr
      while(a[i, piv] == 0 && i < m){
        i <- i+1
        if(i > m){
          i <- row_curr
          piv <- piv+1
          if(piv > n)
            return(a)
        }
      }
      
      # jika diagonal bernilai nol, lakukan row swapping
      if(i != row_curr)
        a <- swap_row(a, i, row_curr)
      
      # proses triangulasi untuk membentuk matriks segitiga atas
      for(j in row_curr:m)
        if(j != row_curr){
          c <- a[j, piv]/a[row_curr, piv]
          a <- replace_row(a, row_curr, j, -c)
        }
      piv <- piv+1
    }
  }
  return(a)
}
```
Diasumsikan terdapat sebuat matrix
```{r}
am <- c(1,1,2,
        1,2,1,
        1,-1,2,
        6,2,10)
(m <- matrix(am, nrow=3))

```
Carilah solusi dari persamaan matrix di atas
```{r}
ref_matrix(m)
```
## Eliminasi Gauss - Jordan
create a matrix
```{r}
A <- matrix(c(-3,2,-1,6,-6,7,3,-4,4),byrow = T,nrow=3,ncol=3)
A
b <- matrix(c(-1,-7,-6),nrow=3,ncol=1)
b 
```
dimension of matrix A
```{r}
nrow <- nrow(A)
nrow
```
concatenante matrix A and vector b to create Augmented Matrix Ugmt.mtx
```{r}
Ugmt.mtx <- cbind(A,b)
Ugmt.mtx

Ugmt.mtx[1,] <- Ugmt.mtx[1,]/Ugmt.mtx[1,1]
Ugmt.mtx
```

ILUSTRASI:
```{r}
Ugmt.mtx[2, ] <- Ugmt.mtx[2, ] - Ugmt.mtx[2-1, ] * Ugmt.mtx[2, 2-1] #pembuat nol element matrix
Ugmt.mtx

```
```{r}
Ugmt.mtx[2,] <- Ugmt.mtx[2,]/Ugmt.mtx[2,2] #pembuat =1 diagonal matrix
Ugmt.mtx
```
dst, dalam bentuk loop:
```{r}
A <- matrix(c(-3,2,-1,6,-6,7,3,-4,4),byrow = T,nrow=3,ncol=3)
A
b <- matrix(c(-1,-7,-6),nrow=3,ncol=1)
b 
nrow <- nrow(A)
Ugmt.mtx <- cbind(A,b)
Ugmt.mtx

Ugmt.mtx[1,] <- Ugmt.mtx[1,]/Ugmt.mtx[1,1]
Ugmt.mtx
for (i in 2:nrow){ # loop over rows
  for (j in i:nrow) { # loop over columns
    Ugmt.mtx[j, ] <- Ugmt.mtx[j, ] - Ugmt.mtx[i-1, ] * Ugmt.mtx[j, i-1] # replace the row values at jth position with left hand computations
  }
  Ugmt.mtx[i,] <- Ugmt.mtx[i,]/Ugmt.mtx[i,i]
}
# print output
Ugmt.mtx #Back Susbstitution needed
```
in case we want to do it. and want to produce the solution instantly:
ILUSTRASI:
```{r}
A <- matrix(c(-3,2,-1,6,-6,7,3,-4,4),byrow = T,nrow=3,ncol=3)
A
b <- matrix(c(-1,-7,-6),nrow=3,ncol=1)
b
# dimension of matrix A
nrow <- nrow(A)
nrow
# concatenante matrix A and vector b
Ugmt.mtx <- cbind(A,b)
Ugmt.mtx
Ugmt.mtx[1,] <- Ugmt.mtx[1,]/Ugmt.mtx[1,1]
for (i in 2:nrow){ # loop over rows
  for (j in i:nrow) { # loop over columns
    Ugmt.mtx[j, ] <- Ugmt.mtx[j, ] - Ugmt.mtx[i-1, ] * Ugmt.mtx[j, i-1] # replace the row values at jth position with left hand computations
  }
  Ugmt.mtx[i,] <- Ugmt.mtx[i,]/Ugmt.mtx[i,i]
}

Ugmt.mtx[1, ] <- Ugmt.mtx[1, ] - Ugmt.mtx[2, ] * Ugmt.mtx[1, 2]
Ugmt.mtx
```
Dengan menggunakan loop:
```{r}
A <- matrix(c(-3,2,-1,6,-6,7,3,-4,4),byrow = T,nrow=3,ncol=3)
A
b <- matrix(c(-1,-7,-6),nrow=3,ncol=1)
b
# dimension of matrix A
nrow <- nrow(A)
nrow
# concatenante matrix A and vector b
Ugmt.mtx <- cbind(A,b)
Ugmt.mtx
Ugmt.mtx[1,] <- Ugmt.mtx[1,]/Ugmt.mtx[1,1]
for (i in 2:nrow){
  for (j in i:nrow) {
    Ugmt.mtx[j, ] <- Ugmt.mtx[j, ] - Ugmt.mtx[i-1, ] * Ugmt.mtx[j, i-1]
  }
  Ugmt.mtx[i,] <- Ugmt.mtx[i,]/Ugmt.mtx[i,i]
}
for (i in j:2){
  for (j in i:2-1) {
    Ugmt.mtx[j, ] <- Ugmt.mtx[j, ] - Ugmt.mtx[i, ] * Ugmt.mtx[j, i]
  }
}
Ugmt.mtx

```
#Metode Iterasi


## Jacobi iteration 

```{r}
jacobi <- function(A, b, x0, tol=1e-6, maxiter=1000) {
  n <- length(b)
  x <- x0
  for (iter in 1:maxiter) {
    x_new <- numeric(n)
    for (i in 1:n) {
      s <- 0
      for (j in 1:n) {
        if (j != i) {
          s <- s + A[i,j] * x[j]
        }
      }
      x_new[i] <- (b[i] - s) / A[i,i]
    }
    if (all(abs(x - x_new) < tol)) {
      break
    }
    x <- x_new
  }
  return(list(x=x, iter=iter))
}
```
Contoh penggunaan:
```{r}
A <- matrix(c(3,1,-1,4,7,-3,2,-2,5), nrow=3, byrow=TRUE)
b <- c(5,20,10)
x0 <- c(0,0,0)
result <- jacobi(A, b, x0)
x <- result$x
iter <- result$iter
cat("The solution is x =", x, " after ", iter, " iterations\n")
```
## Gauss Seidel iteration
```{r}
gaussSeidel <- function(A, b, epsilon, maxIterations) {
  # Extract the size of the system
  n <- length(b)
  
  # Initialize the solution vector x
  x <- numeric(n)
  
  # Iterate until either epsilon is reached or maxIterations is reached
  for (iteration in 1:maxIterations) {
    x_old <- x
    
    # Update each variable using the Gauss-Seidel formula
    for (i in 1:n) {
      x[i] <- (b[i] - sum(A[i, -i] * x[-i])) / A[i, i]
    }
    
    # Check if epsilon is reached
    if (max(abs(x - x_old)) < epsilon) {
      break
    }
  }
  
  # Return the solution and the number of iterations
  list(x = x, iterations = iteration)
}
```
Contoh aplikasi penggunaan:
```{r}
#A <- matrix(c(4, 1, 1, 4, 1, 1, 1, 1, 4), nrow = 3)
#b <- c(6, 6, 6)
result <- gaussSeidel(A, b, 1e-6, 100)
x <- result$x
iterations <- result$iterations
cat("Number of iterations:", iterations, "\n")
cat("Solution:", x, "\n")
```

## STUDI KASUS
```{r}
head(trees)
str(trees)
plot(trees)
```
bentuk dalam sebuah matrix
```{r}
pred <- cbind(intercept=1, Girth=trees$Girth, Height=trees$Height)
head(pred)
```
Langkah selanjutnya adalah membentuk vektor b
```{r}
resp<- trees$Volume
head(resp)
```
lakukan transformasi:
```{r}
A <- t(pred) %*% pred #(X'X)
b <- t(pred) %*% resp #(X'y)
Ab <- cbind(A,b)
```
Dengan menggunakan metode eliminasi Gauss/ Row echelon form:
```{r}
ref_matrix(Ab)
```
Menggunakan substitusi balik didapatkan koefficient variable height: 301.7857/889.5641 = 0.3392512
```{r}
301.7857/889.5641
```


Dengan menggunakan metode eliminasi Gauss Jordan:
```{r}
Ugmt.mtx <- cbind(A,b)
Ugmt.mtx[1,] <- Ugmt.mtx[1,]/Ugmt.mtx[1,1]
for (i in 2:nrow){
  for (j in i:nrow) {
    Ugmt.mtx[j, ] <- Ugmt.mtx[j, ] - Ugmt.mtx[i-1, ] * Ugmt.mtx[j, i-1]
  }
  Ugmt.mtx[i,] <- Ugmt.mtx[i,]/Ugmt.mtx[i,i]
}
for (i in j:2){
  for (j in i:2-1) {
    Ugmt.mtx[j, ] <- Ugmt.mtx[j, ] - Ugmt.mtx[i, ] * Ugmt.mtx[j, i]
  }
}
Ugmt.mtx
```
Dengan menggunakan metode iterative Jacobi ?

Dengan menggunakan metode iterative Gauss Siedel:

```{r}
result <- gaussSeidel(A, b, 1e-6, 1000)
x <- result$x
iterations <- result$iterations
cat("Number of iterations:", iterations, "\n")
cat("Solution:", x, "\n")
```
Dengan menggunakan fungsi base R
```{r}
## fungsi solve
solve(A,b)
```







