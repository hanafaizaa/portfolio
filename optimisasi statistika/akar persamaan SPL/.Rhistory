for (i in 2:nrow){
for (j in i:nrow) {
Ugmt.mtx[j, ] <- Ugmt.mtx[j, ] - Ugmt.mtx[i-1, ] * Ugmt.mtx[j, i-1]
}
Ugmt.mtx[i,] <- Ugmt.mtx[i,]/Ugmt.mtx[i,i]
}
for (i in p:2){
for (j in i:2-1) {
Ugmt.mtx[j, ] <- Ugmt.mtx[j, ] - Ugmt.mtx[i, ] * Ugmt.mtx[j, i]
}
}
for (i in 2:nrow){
for (j in i:nrow) {
Ugmt.mtx[j, ] <- Ugmt.mtx[j, ] - Ugmt.mtx[i-1, ] * Ugmt.mtx[j, i-1]
}
Ugmt.mtx[i,] <- Ugmt.mtx[i,]/Ugmt.mtx[i,i]
}
for (i in j:2){
for (j in i:2-1) {
Ugmt.mtx[j, ] <- Ugmt.mtx[j, ] - Ugmt.mtx[i, ] * Ugmt.mtx[j, i]
}
}
Ugmt.mtx
A <- matrix(c(-3,2,-1,6,-6,7,3,-4,4),byrow = T,nrow=3,ncol=3)
A
b <- matrix(c(-1,-7,-6),nrow=3,ncol=1)
b
# dimension of matrix A
nrow <- nrow(A)
nrow
# concatinante matrix A and vector b
Ugmt.mtx <- cbind(A,b)
Ugmt.mtx
Ugmt.mtx[2, ] <- Ugmt.mtx[2, ] - Ugmt.mtx[2-1, ] * Ugmt.mtx[2, 2-1]
Ugmt.mtx
Ugmt.mtx[2,] <- Ugmt.mtx[2,]/Ugmt.mtx[2,2]
Ugmt.mtx
Ugmt.mtx[1,] <- Ugmt.mtx[1,]/Ugmt.mtx[1,1]
Ugmt.mtx
A <- matrix(c(-3,2,-1,6,-6,7,3,-4,4),byrow = T,nrow=3,ncol=3)
A # print a matrix
b <- matrix(c(-1,-7,-6),nrow=3,ncol=1)
b # print matrix b
# dimension of matrix A
nrow <- nrow(A)
nrow
Ugmt.mtx <- cbind(A,b)
Ugmt.mtx
Ugmt.mtx[1,] <- Ugmt.mtx[1,]/Ugmt.mtx[1,1]
for (i in 2:nrow){ # loop over rows
for (j in i:nrow) { # loop over columns
Ugmt.mtx[j, ] <- Ugmt.mtx[j, ] - Ugmt.mtx[i-1, ] * Ugmt.mtx[j, i-1] # replace the row values at jth position with left hand computations
}
Ugmt.mtx[i,] <- Ugmt.mtx[i,]/Ugmt.mtx[i,i]
}
# print ouput
Ugmt.mtx #Back Susbstitution needed
Ugmt.mtx
A <- matrix(c(-3,2,-1,6,-6,7,3,-4,4),byrow = T,nrow=3,ncol=3)
A # print a matrix
b <- matrix(c(-1,-7,-6),nrow=3,ncol=1)
b # print matrix b
# dimension of matrix A
nrow <- nrow(A)
nrow
# concatenante matrix A and vector b to create Augmented Matrix Ugmt.mtx
Ugmt.mtx <- cbind(A,b)
Ugmt.mtx
Ugmt.mtx[2, ] <- Ugmt.mtx[2, ] - Ugmt.mtx[2-1, ] * Ugmt.mtx[2, 2-1]
A <- matrix(c(-3,2,-1,6,-6,7,3,-4,4),byrow = T,nrow=3,ncol=3)
A # print a matrix
b <- matrix(c(-1,-7,-6),nrow=3,ncol=1)
b # print matrix b
# dimension of matrix A
nrow <- nrow(A)
nrow
# concatenante matrix A and vector b to create Augmented Matrix Ugmt.mtx
Ugmt.mtx <- cbind(A,b)
Ugmt.mtx
Ugmt.mtx[1,] <- Ugmt.mtx[1,]/Ugmt.mtx[1,1]
Ugmt.mtx
Ugmt.mtx[2, ] <- Ugmt.mtx[2, ] - Ugmt.mtx[2-1, ] * Ugmt.mtx[2, 2-1]
Ugmt.mtx
Ugmt.mtx[2,] <- Ugmt.mtx[2,]/Ugmt.mtx[2,2]
Ugmt.mtx
for (i in 2:nrow){ # loop over rows
for (j in i:nrow) { # loop over columns
Ugmt.mtx[j, ] <- Ugmt.mtx[j, ] - Ugmt.mtx[i-1, ] * Ugmt.mtx[j, i-1] # replace the row values at jth position with left hand computations
}
Ugmt.mtx[i,] <- Ugmt.mtx[i,]/Ugmt.mtx[i,i]
}
Ugmt.mtx
Ugmt.mtx[1, ] <- Ugmt.mtx[1, ] - Ugmt.mtx[1, ] * Ugmt.mtx[1, 1]
Ugmt.mtx
for (i in 2:nrow){ # loop over rows
for (j in i:nrow) { # loop over columns
Ugmt.mtx[j, ] <- Ugmt.mtx[j, ] - Ugmt.mtx[i-1, ] * Ugmt.mtx[j, i-1] # replace the row values at jth position with left hand computations
}
Ugmt.mtx[i,] <- Ugmt.mtx[i,]/Ugmt.mtx[i,i]
}
Ugmt.mtx
source("~/Documents/2023/2023 - MATA KULIAH/Optimasi Statistika/Practical/SPL Hands On.R", echo=TRUE)
A <- matrix(c(-3,2,-1,6,-6,7,3,-4,4),byrow = T,nrow=3,ncol=3)
A # print a matrix
b <- matrix(c(-1,-7,-6),nrow=3,ncol=1)
b # print matrix b
# dimension of matrix A
nrow <- nrow(A)
nrow
# concatenante matrix A and vector b to create Augmented Matrix Ugmt.mtx
Ugmt.mtx <- cbind(A,b)
Ugmt.mtx
Ugmt.mtx[1,] <- Ugmt.mtx[1,]/Ugmt.mtx[1,1]
Ugmt.mtx
for (i in 2:nrow){ # loop over rows
for (j in i:nrow) { # loop over columns
Ugmt.mtx[j, ] <- Ugmt.mtx[j, ] - Ugmt.mtx[i-1, ] * Ugmt.mtx[j, i-1] # replace the row values at jth position with left hand computations
}
Ugmt.mtx[i,] <- Ugmt.mtx[i,]/Ugmt.mtx[i,i]
}
# print output
Ugmt.mtx #Back Susbstitution needed
Ugmt.mtx[2, ] <- Ugmt.mtx[2, ] - Ugmt.mtx[1, ] * Ugmt.mtx[2, 1]
Ugmt.mtx
Ugmt.mtx[2, ] <- Ugmt.mtx[2, ] - Ugmt.mtx[2, ] * Ugmt.mtx[1, 2]
Ugmt.mtx
A <- matrix(c(-3,2,-1,6,-6,7,3,-4,4),byrow = T,nrow=3,ncol=3)
A
b <- matrix(c(-1,-7,-6),nrow=3,ncol=1)
b
# dimension of matrix A
nrow <- nrow(A)
nrow
# concatenante matrix A and vector b
Ugmt.mtx <- cbind(A,b)
Ugmt.mtx
Ugmt.mtx[1,] <- Ugmt.mtx[1,]/Ugmt.mtx[1,1]
for (i in 2:nrow){ # loop over rows
for (j in i:nrow) { # loop over columns
Ugmt.mtx[j, ] <- Ugmt.mtx[j, ] - Ugmt.mtx[i-1, ] * Ugmt.mtx[j, i-1] # replace the row values at jth position with left hand computations
}
Ugmt.mtx[i,] <- Ugmt.mtx[i,]/Ugmt.mtx[i,i]
}
Ugmt.mtx
Ugmt.mtx[1, ] <- Ugmt.mtx[1, ] - Ugmt.mtx[2, ] * Ugmt.mtx[1, 2]
Ugmt.mtx
A <- matrix(c(-3,2,-1,6,-6,7,3,-4,4),byrow = T,nrow=3,ncol=3)
A
b <- matrix(c(-1,-7,-6),nrow=3,ncol=1)
b
# dimension of matrix A
nrow <- nrow(A)
nrow
# concatenante matrix A and vector b
Ugmt.mtx <- cbind(A,b)
Ugmt.mtx
Ugmt.mtx[1,] <- Ugmt.mtx[1,]/Ugmt.mtx[1,1]
for (i in 2:nrow){ # loop over rows
for (j in i:nrow) { # loop over columns
Ugmt.mtx[j, ] <- Ugmt.mtx[j, ] - Ugmt.mtx[i-1, ] * Ugmt.mtx[j, i-1] # replace the row values at jth position with left hand computations
}
Ugmt.mtx[i,] <- Ugmt.mtx[i,]/Ugmt.mtx[i,i]
}
Ugmt.mtx
Ugmt.mtx[1, ] <- Ugmt.mtx[1, ] - Ugmt.mtx[2, ] * Ugmt.mtx[1, 2]
Ugmt.mtx
A <- matrix(c(-3,2,-1,6,-6,7,3,-4,4),byrow = T,nrow=3,ncol=3)
A # print a matrix
b <- matrix(c(-1,-7,-6),nrow=3,ncol=1)
b # print matrix b
# dimension of matrix A
nrow <- nrow(A)
nrow
# concatenante matrix A and vector b to create Augmented Matrix Ugmt.mtx
Ugmt.mtx <- cbind(A,b)
Ugmt.mtx
Ugmt.mtx[1,] <- Ugmt.mtx[1,]/Ugmt.mtx[1,1]
Ugmt.mtx
for (i in 2:nrow){
for (j in i:nrow) {
Ugmt.mtx[j, ] <- Ugmt.mtx[j, ] - Ugmt.mtx[i-1, ] * Ugmt.mtx[j, i-1]
}
Ugmt.mtx[i,] <- Ugmt.mtx[i,]/Ugmt.mtx[i,i]
}
for (i in j:2){
for (j in i:2-1) {
Ugmt.mtx[j, ] <- Ugmt.mtx[j, ] - Ugmt.mtx[i, ] * Ugmt.mtx[j, i]
}
}
Ugmt.mtx
ref_matrix <- function(a){
m <- nrow(a)
n <- ncol(a)
piv <- 1
# cek elemen diagonal apakah bernilai nol
for(row_curr in 1:m){
if(piv <= n){
i <- row_curr
while(a[i, piv] == 0 && i < m){
i <- i+1
if(i > m){
i <- row_curr
piv <- piv+1
if(piv > n)
return(a)
}
}
# jika diagonal bernilai nol, lakukan row swapping
if(i != row_curr)
a <- swap_row(a, i, row_curr)
# proses triangulasi untuk membentuk matriks segitiga atas
for(j in row_curr:m)
if(j != row_curr){
c <- a[j, piv]/a[row_curr, piv]
a <- replace_row(a, row_curr, j, -c)
}
piv <- piv+1
}
}
return(a)
}
am <- c(1,1,2,
1,2,1,
1,-1,2,
6,2,10)
bm <- c(1,1,2,
1,2,1,
1,-1,2)
cm <- c(6,2,10)
m1 <- matrix(bm, 3)
aug_m <- cbind(m1, cm)
(m <- matrix(am, nrow=3))
ref_matrix(m)
m <- matrix(am, nrow=3
)
m <- matrix(am, nrow=3)
ref_matrix(m)
?row_curr
for(row_curr in 1:m){
if(piv <= n){
i <- row_curr
while(a[i, piv] == 0 && i < m){
i <- i+1
if(i > m){
i <- row_curr
piv <- piv+1
if(piv > n)
return(a)
}
}
#Metode Iterasi
A <- matrix(c(5,2,1,2,7,3,3,4,8), 3)
b <- c(40,39,55)
)
b <- c(40,39,55)
x <- rep(0,3)
A
b
x
#Langkah selanjutnya adalah memperoleh invers matriks D
Dinv <- diag(1/diag(A))
?diag
Dinv
#Metode Iterasi
(A <- matrix(c(5,2,1,2,7,3,3,4,8), 3))
b <- c(40,39,55)
x <- rep(0,3)
#Langkah selanjutnya adalah memperoleh invers matriks D
Dinv <- diag(1/diag(A))
Dinv
#Persiapan terakhir sebelum iterasi dilakukan adalah menyiapkan matriks R
(R<-A-diag(diag(A)))
(diag(diag(A)))
?diag()
diag(A)
?diag(diag())
(diag(diag(A)))
#Persiapan terakhir sebelum iterasi dilakukan adalah menyiapkan matriks R
(R<-A-diag(diag(A)))
Dinv
#Iterasi 1
(x1 <- Dinv %*% (b-R%*%x))
#Iterasi 2
(x2 <- Dinv %*% (b-R%*%x1))
#Iterasi 3
(x3 <- Dinv %*% (b-R%*%x2))
#Selama proses iterasi,jumlah akar jumlah kuadrat dihitung.
#Sebagai contoh berikut disajikan akar jumlah kuadrat pada iterasi ke-3:
sqrt(sum(x3-x2)^2)
jacobi <- function(a, b, tol=1e-7, maxiter=100){
n <- length(b)
iter <- 0
Dinv <- diag(1/diag(a))
R <- a-diag(diag(a))
x <- rep(0,n)
x_new <- rep(tol, n)
while(sqrt(sum(x_new-x)^2)>tol){
if(iter>maxiter){
warning("iterasi maksimum tercapai")
break
}
x <- x_new
x_new <- Dinv %*% (b - R %*% x)
iter <- iter+1
}
return(list(X = x_new, iter=iter))
}
###penarapan fungsi jacobi(A,b)
jacobi(A,b)
###Contoh:
A <- matrix(c(27,6,1,6,15,1,-1,2,54), 3)
b <- c(85,72,110)
jacobi(A,b)
###fungsi base untuk menemukan solusi SPL:
solve(A,b)
##Metode Iterasi Gauss Seidel
# membentuk matriks U dan L dari matriks A
(L <- U <- A)
# membentuk matriks L dari entri bagian bawah diagonal utama matriks A
L[upper.tri(A, diag=FALSE)]<-0
L
# membentuk matriks U dari entri bagian atas diagonal utama matriks A
U[lower.tri(A, diag=TRUE)]<-0
U
e
(Linv <- solve(L))
# Selanjutya lakukan invers terhadap matriks  L menggunakn fungsi solve()
(Linv <- solve(L))
# tebakan awal nilai x
(x <- rep(0, length(b)))
#Iterasi 1
(x1 <- Linv %*% (b - U %*% x))
# akar jumlah kuadrat
sqrt(sum(x1-x)^2)
#Iterasi 2
(x2 <- Linv %*% (b - U %*% x1))
# akar jumlah kuadrat
sqrt(sum(x2-x1)^2)
gauss_seidel <- function(a, b, tol=1e-7, maxiter=100){
n <- length(b)
iter <- 0
L <- U <- a
L[upper.tri(a, diag=FALSE)] <- 0
U[lower.tri(a, diag=TRUE)] <- 0
Linv <- solve(L)
x <- rep(0,n)
x_new <- rep(tol, n)
while(sqrt(sum(x_new-x)^2)>tol){
if(iter>maxiter){
warning("iterasi maksimum tercapai")
break
}
x <- x_new
x_new <- Linv %*% (b - U %*% x)
iter <- iter+1
}
return(list(X = x_new, iter=iter))
}
gauss_seidel(A,b)
###STUDI KASUS
head(trees)
str(trees)
scatterplot(trees)
scaterplot(trees)
?scaterplot
??scaterplot
plot(trees)
pred <- cbind(intercept=1, Girth=trees$Girth, Height=trees$Height)
head(A)
resp<- trees$Volume
head(resp)
A <- t(pred) %*% pred
b <- t(pred) %*% resp
Ab <- cbind(A,b)
(x <- gauss_jordan(Ab))
(x <- gauss_jordan(A,b))
(x <- gauss_jordan(Ab))
gauss_jordan <- function (a){
m <- nrow (a)
n <- ncol (a)
piv <- 1
# cek elemen diagonal utama apakah bernilai nol
for(row_curr in 1:m){
if(piv <= n){
i <- row_curr
while(a[i, piv] == 0 && i < m){
i <- i + 1
if(i > m){
i <- row_curr
piv <- piv + 1
if(piv > n)
return (a)
}
}
# jika diagonal utama bernilai nol,lakukan row swapping
if(i != row_curr)
a <- swap_row(a, i, row_curr)
# proses pembentukan matriks reduced row echelon form
piv_val <- a[row_curr , piv]
a <- scale_row (a, row_curr , 1 / piv_val)
for(j in 1: m){
if(j != row_curr){
k <- a[j, piv]/a[row_curr, piv]
a <- replace_row (a, row_curr, j, -k)
}
}
piv <- piv + 1
}
}
return (a)
}
(m <- matrix(c(1,2,1,4,3,8), nrow=2))
gauss_jordan(m)
(x <- gauss_jordan(A,b))
(x <- gauss_jordan(Ab))
## metode LU
lu_solve(A,b)
## fungsi solve
solve(A,b)
dim(trees)
head(trees)
mtrees <- as.matrix(trees)
nrow(mtrees)
dim(mtrees)
Ugmt.mtx <- as.matrix(trees)
Ugmt.mtx[1,] <- Ugmt.mtx[1,]/Ugmt.mtx[1,1]
for (i in 2:nrow){ # loop over rows
for (j in i:nrow) { # loop over columns
Ugmt.mtx[j, ] <- Ugmt.mtx[j, ] - Ugmt.mtx[i-1, ] * Ugmt.mtx[j, i-1] # replace the row values at jth position with left hand computations
}
Ugmt.mtx[i,] <- Ugmt.mtx[i,]/Ugmt.mtx[i,i]
}
Ugmt.mtx[1, ] <- Ugmt.mtx[1, ] - Ugmt.mtx[2, ] * Ugmt.mtx[1, 2]
Ugmt.mtx
gauss_jordan(Ugmt.mtx)
A <- t(pred) %*% pred
b <- t(pred) %*% resp
Ab <- cbind(A,b)
Ab
Ugmt.mtx <- cbind(A,b)
Ugmt.mtx[1,] <- Ugmt.mtx[1,]/Ugmt.mtx[1,1]
for (i in 2:nrow){
for (j in i:nrow) {
Ugmt.mtx[j, ] <- Ugmt.mtx[j, ] - Ugmt.mtx[i-1, ] * Ugmt.mtx[j, i-1]
}
Ugmt.mtx[i,] <- Ugmt.mtx[i,]/Ugmt.mtx[i,i]
}
for (i in j:2){
for (j in i:2-1) {
Ugmt.mtx[j, ] <- Ugmt.mtx[j, ] - Ugmt.mtx[i, ] * Ugmt.mtx[j, i]
}
}
Ugmt.mtx
pred
Ugmt.mtx[1,] <- Ugmt.mtx[1,]/Ugmt.mtx[1,1]
for (i in 2:nrow){
for (j in i:nrow) {
Ugmt.mtx[j, ] <- Ugmt.mtx[j, ] - Ugmt.mtx[i-1, ] * Ugmt.mtx[j, i-1]
}
Ugmt.mtx[i,] <- Ugmt.mtx[i,]/Ugmt.mtx[i,i]
}
for (i in j:2){
for (j in i:2-1) {
Ugmt.mtx[j, ] <- Ugmt.mtx[j, ] - Ugmt.mtx[i, ] * Ugmt.mtx[j, i]
}
}
Ugmt.mtx
jacobi(A,b)
gauss_seidel(Ab)
gauss_seidel(A,b)
gauss_seidel <- function(a, b, tol=1e-7, maxiter=1000){
n <- length(b)
iter <- 0
L <- U <- a
L[upper.tri(a, diag=FALSE)] <- 0
U[lower.tri(a, diag=TRUE)] <- 0
Linv <- solve(L)
x <- rep(0,n)
x_new <- rep(tol, n)
while(sqrt(sum(x_new-x)^2)>tol){
if(iter>maxiter){
warning("iterasi maksimum tercapai")
break
}
x <- x_new
x_new <- Linv %*% (b - U %*% x)
iter <- iter+1
}
return(list(X = x_new, iter=iter))
}
gauss_seidel(A,b)
gauss_seidel <- function(a, b, tol=1e-7, maxiter=1000){
n <- length(b)
iter <- 0
L <- U <- a
L[upper.tri(a, diag=FALSE)] <- 0
U[lower.tri(a, diag=TRUE)] <- 0
Linv <- solve(L)
x <- rep(0,n)
x_new <- rep(tol, n)
while(sqrt(sum(x_new-x)^2)>tol){
if(iter>maxiter){
warning("iterasi maksimum tercapai")
break
}
x <- x_new
x_new <- Linv %*% (b - U %*% x)
iter <- iter+1
}
return(list(X = x_new, iter=iter))
}
gauss_seidel(A,b)
